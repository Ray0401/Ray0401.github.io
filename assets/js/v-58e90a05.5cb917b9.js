"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[662],{7862:(i,e,a)=>{a.r(e),a.d(e,{data:()=>l});const l={key:"v-58e90a05",path:"/uniapp/",title:"Uniapp 5+项目重构分享",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"为什么重构:",slug:"为什么重构",children:[]},{level:2,title:"重构过程:",slug:"重构过程",children:[{level:3,title:"开发模版选用",slug:"开发模版选用",children:[]},{level:3,title:"目录结构",slug:"目录结构",children:[]},{level:3,title:"ts",slug:"ts",children:[]},{level:3,title:"uniapp 如何实现响应式",slug:"uniapp-如何实现响应式",children:[]},{level:3,title:"vue3",slug:"vue3",children:[]},{level:3,title:"vite",slug:"vite",children:[]},{level:3,title:"http 拦截",slug:"http-拦截",children:[]},{level:3,title:"主题切换",slug:"主题切换",children:[]},{level:3,title:"pinia",slug:"pinia",children:[]},{level:3,title:"hooks",slug:"hooks",children:[]},{level:3,title:"app 调试器",slug:"app-调试器",children:[]}]}],filePathRelative:"uniapp/index.md",git:{updatedTime:null,contributors:[]}}},7066:(i,e,a)=>{a.r(e),a.d(e,{default:()=>n});const l=(0,a(6252).uE)('<h1 id="uniapp-5-项目重构分享" tabindex="-1"><a class="header-anchor" href="#uniapp-5-项目重构分享" aria-hidden="true">#</a> Uniapp 5+项目重构分享</h1><h2 id="为什么重构" tabindex="-1"><a class="header-anchor" href="#为什么重构" aria-hidden="true">#</a> 为什么重构:</h2><ol><li>template 重复书写,未考虑到扩展性; <img src="/images/uniapp/img3.png" alt=""></li><li>公共 css 未做抽离,每个组件都需要写一遍;</li><li>黑白主题实现方式复杂,需要每个页面对两种主题进行 css 编写 <img src="/images/uniapp/img1.png" alt=""></li><li>组件未进行复用,一个下拉框功能便是一个组件 <img src="/images/uniapp/img2.png" alt=""></li><li>未严格判断数据类型,以及接口数据处理不当 <img src="/images/uniapp/img4.png" alt=""></li><li>http 拦截器逻辑混乱</li><li>options api 的通用毛病,以及 mixin 的滥用</li><li>使用了 loadsh 等大库,还未做按需引入,只是为了使用其中的防抖函数</li><li>uni_modules 里有很多无效组件</li><li>启动项目较慢</li><li>线上出现问题,没办法像浏览器一样查看调试器,排查问题低效</li></ol><p>...</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p><em>在开发过程中上述的问题造成了很多心智负担,项目也越来越臃肿,代码质量也越来越差;遂在 v1.0.3 提测后,进行项目重构,便于后期迭代以及多人协作开发同时也对项目制定了更严格的开发规范(husky + commitlint + prettier)</em></p></div><h2 id="重构过程" tabindex="-1"><a class="header-anchor" href="#重构过程" aria-hidden="true">#</a> 重构过程:</h2><p>vue3+vite+ts+pinia</p><h3 id="开发模版选用" tabindex="-1"><a class="header-anchor" href="#开发模版选用" aria-hidden="true">#</a> 开发模版选用</h3><p>1.创建最新的 cli 工程 2.manifeset.json 中再对 app 打包进行配置</p><p>这样一个 5+项目都搭建好了</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>npx degit dcloudio/uni-preset-vue<span class="token comment">#vite-ts my-vue3-project</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="目录结构" tabindex="-1"><a class="header-anchor" href="#目录结构" aria-hidden="true">#</a> 目录结构</h3><h3 id="ts" tabindex="-1"><a class="header-anchor" href="#ts" aria-hidden="true">#</a> ts</h3><ul><li>d.ts 文件是什么</li><li>如何处理 npm 包以及其他 js 文件 (declare module)</li><li>interface</li><li>json to ts</li><li>接口 promise 处理</li></ul><h3 id="uniapp-如何实现响应式" tabindex="-1"><a class="header-anchor" href="#uniapp-如何实现响应式" aria-hidden="true">#</a> uniapp 如何实现响应式</h3><p>page-meta</p><h3 id="vue3" tabindex="-1"><a class="header-anchor" href="#vue3" aria-hidden="true">#</a> vue3</h3><ul><li>provide 与 inject</li><li>ref 与 defineExpose 结合</li><li>自定义组件的双向数据绑定</li><li>自定义 button 组件</li></ul><h3 id="vite" tabindex="-1"><a class="header-anchor" href="#vite" aria-hidden="true">#</a> vite</h3><h3 id="http-拦截" tabindex="-1"><a class="header-anchor" href="#http-拦截" aria-hidden="true">#</a> http 拦截</h3><ul><li>url 管理</li><li>接口 api 管理</li><li>接口 URL 参数处理</li></ul><h3 id="主题切换" tabindex="-1"><a class="header-anchor" href="#主题切换" aria-hidden="true">#</a> 主题切换</h3><ul><li>:root 中定义变量</li></ul><h3 id="pinia" tabindex="-1"><a class="header-anchor" href="#pinia" aria-hidden="true">#</a> pinia</h3><ul><li>无 mutation</li><li>数据持久化</li></ul><h3 id="hooks" tabindex="-1"><a class="header-anchor" href="#hooks" aria-hidden="true">#</a> hooks</h3><p>vue3 借鉴 react hooks 开发出了 Composition API ，所以也就意味着 Composition API 也能进行自定义封装 hooks。</p><p>vue3 中的 hooks 就是函数的一种写法，就是将文件的一些单独功能的 js 代码进行抽离出来，放到单独的 js 文件中，或者说是一些可以复用的公共方法/功能。其实 hooks 和 vue2 中的 mixin 有点类似，但是相对 mixins 而言， hooks 更清楚复用功能代码的来源, 更清晰易懂。</p><h3 id="app-调试器" tabindex="-1"><a class="header-anchor" href="#app-调试器" aria-hidden="true">#</a> app 调试器</h3>',29),t={},n=(0,a(3744).Z)(t,[["render",function(i,e){return l}]])},3744:(i,e)=>{e.Z=(i,e)=>{const a=i.__vccOpts||i;for(const[i,l]of e)a[i]=l;return a}}}]);